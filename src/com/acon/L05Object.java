package com.acon;

public class L05Object {
    int a ; // 전역변수 this.a로 접근할수 있는 해당 객체의 필드이다.
    public void print (){
        System.out.println(this.a);
    } // 필드에 있는 함수 this.print()로 접근가능
    static int b;// this.b (x)가능은 하나 잘못된 방식 ,  L05Object.b (O) 정적멤버는 클래스 이름만 사용.

    Object o = new Object();

    //📂 생성자
    public L05Object(){}//기본 생성자

//    public L05Object constructor(){ return new L05Object(10,o)}  생성자는 이런 함수라고 생각하면 반환타입이 자기자신이기 때문에 반환하는 생략된다고 보면 된다.
    public L05Object(int a, Object o){//생성자 함수와 비슷하지만 클래스 명으로 자성
        this.a =a;
        this.o =o;
    }

    public static void main(String[] args) {

        //int i = 0 ; // 기본형 type 은 Class 가 아니다.
        //📂 class, 자료형 Type,=>그냥  type 또는 객체의 타입 이라고도 부른다

        //📂 필드(Field),속성(Attribute),멤버: 전체 영역(최상위블럭)에 선언된 것들 (static 제외)
        //  -> this.필드 접근자 (필드: 클래스 전체 영역에 선언된것들 , static 제외) 해당 클래스가 객체가 되었을때
        //  ->static 인것은 정적 영역 필드에 있으며 클래스 이름만 사용한다.(클래스 이름으로 호출)

        //📂 객체(Object), 인스턴스(instance)
        //  -> new 연산자로 해당 클래스의 생성자를 호출했을때 반환하는 것.
        // Class Object : 개발자가 타입을 명시하고 객체를 생성할 수 있도록 하는 최초의 설계도(모든 타입의 부모-> 조상)

        //main 함수는 정적멤버 이기 때문에 (L05Object 의 필드가 아니기 때문에 )this 를 사용할 수 없다.
            //this.b = 10 ; (X)
            b = 10; //(O) 정적멤버끼리는 바로 호출이 가능하다.

        //📂 메소드: 재사용할 실행의 집합으로 매개변수에 의해 실행을 제어하고 결과를 반환할 수 있다.
        //📂 생성자: 객체를 생성할때 호출되고 필드를 초기화 한다. ( new 연산자가 객체를 생성 /++와 동급의 우선순위를 가지고있다.)
        //          객체 생성시 호출되는 생성자는 매개변수 필드를 초기화(첫 세팅) 할 수 있다.
        //          반환타입을 쓰지 않는 이유: 생성자가 이미 반환하는 타입의 이름을 하고 있기 때문


        //📂 변수: 데이터(data)를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간, 변수 내의 데이터는 수정이 가능.
        //  상수: 최초에 참조한 데이터가 바뀌지 않는것.

        //  지역변수(전역이 아닌 스코프(=영역;메소드,제어문,반복문과 같은 블럭{})에 존재하는 변수(해당 블럭 내에서만 참조 가능한 변수)
        //  전역변수: 해당 타입이(Class) 객체가 되었을때 .으로 참조할 수 있는것. 해당타입(class)이 객체가 되었을 때 재원(필드,속성)이 되는 것
        //  정적변수:(클래스 변수) 라고도 부른다.
        //         JVM 이 구동될때  메소드 영역에 생성되기 때문에 객체 생성없이 참조가능하고 자동삭제 되지 않고 남는다.
        //         자주 사용하면 메모리 낭비가 될 수 있다.
        //         초기화를 거의 하지 않기 때문에(객체 를 새로 생성할때 값이 리셋되는것 처럼 그런 과정이 없고, 계속 코드에 따라 그 값이 변하기 때문에)
        //         기대했던 값이 아닐 수 있다. 따라서 대부분 final 을 붙여 상수로 선언하는 경우가 많다.
        //  매개변수(파라미터): 생성자나 메소드를 실행할때 제공하는 데이터

        //📂 메모리 영역
        //-힙 : 인스턴스 객체(빨리빨리쓰고 빨리빨리 사라진다는 의미의 객체)가 생성되는 곳 , 가비지컬렉션(GC)이 사용하지 않는 객체를 자동으로 지운다.
        //      (java 가 유명하게 된 이유: 객체를 생성할때 일일히 필요없으면 지웠어야했는데( pointer 사용) 자동으로 지워짐 GC;GarbageCollection)
        //-스텍(call Stack) : 작업에 필요한 메모리 공간(그릇형) 메소드 단위, 스케쥴링하여 CPU 에게 보내서 연산시키게 하는 곳
        //                   스텍 메모리 구조(그릇형)를 갖고  main 에서 실행할 변수와 메소드 연산을 스케쥴링해서 참조
        //-메소드 : JVM 이 실행되면서 사용되는 class 를 분석해서 메소드 영역에 저장하는데 이때 static 으로 선언된 정적 맴버를 생성한다. (여긴 GC 가 없다=>메모리 낭비주의)


    }
}
