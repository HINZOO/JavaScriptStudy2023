<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>기본형 데이터 타입</title>
</head>
<body>
    <h1>자바스크립트의 기본형 데이터와 타입</h1>
    <h2>자바의 기본형</h2>
    <ul>
        <li>123 : int</li>
        <li>123423423423423L : long</li>
        <li>true ,false : boolean</li>
        <li>byte : byte  b= (byte) 13;</li>
        <li>short : short b = (short) 13;</li>
        <li>int : int b = 13;</li>
        <li>long : long l =1234455663534242342L</li>
        <li>float : float  f = 123.23f</li>
        <li>double: double d = 123.23 </li>
        <li>boolean</li>
        <li>char : char c = (0~127) 1byte || '\u1231' , '0x1231', '가' 1~4byte </li>
    </ul>

    <h2>JS의 기본형 7가지 (암기!)</h2>
    <ul>
        <li>number : java의 double 과 같은 기본형으로 모든 연산이 가능 (123, 123.123, NaN,Infinity)</li>
        <li>bigint : number 가 가장 정확하게 표현할 수 있는 정수보다 큰 수를 표기할 때 사용 (9007199254740991n)</li>
        <li>string : 문자의 배열형태의 자료로 java의 char[]과 같은 타입이다.("안녕",'',`${변수}`)</li>
        <li>boolean : 논리연산의 결과로 true, false를 나타낸다.</li>
        <li>null : 자료가 없다. 수로  형변환 하면 0으로 취급</li>
        <li>undefined : 선언되지 않음, 선언되지 않은 상태의 변수를 참조할 때 발생하는 오류를 예방하기 위해 존재 (NaN)</li>
        <li>symbol : 고유값을 반환하는 기본 데이터로 Iterable 한 자료의 식별자를 정의할 때 사용 됨. </li>
    </ul>
    <p>type of : 기본형의 타입을 문자열로 반환하는 연산으로 자료형은 모두 object로 반환하고 함수는 function으로 반환한다.</p>
    <h2>number 기본형</h2>
    <ul>
        <li>정수 : 정수를 선언해도 실수가 된다.</li>
        <li>실수 : 8byte 크기의 실수로 java의 double과 똑같다.</li>
        <li>NaN : Not a Number 의 준말로 수로 변환할 수 없는 데이터를 수로 변환할 때 오류를 발생하지 않으려고 등장.</li>
        <li>Infinity : 무한대</li>
    </ul>
    <h2>string 문자열</h2>
    <ul>
        <li>"",'',``으로 선언가능</li>
        <li>메모리에 char[] 의 형태로 저장되어 자료형이지만 자바스크립트에서는 기본형으로 취급한다.</li>
        <li>+(concat()) 더하기 연산이 가능</li>
        <li>자바처럼 리터럴 하게 선언하면 새로운 문자열을 만들지 않고 기존의 문자열을 참조한다. ex)"안녕"==="안녕"//true</li>
    </ul>

    <h2>수 연산자</h2>
    <p> *, /, % , **, +, -, ++, --, +=, -=, *=, /=, %= </p>
    <ul>
        <li>+ : 더하기 연산은 수와 문자열 둘다 연산할 수 있다. 문자열의 + 연산은 String.concat()을 하는 것과 같다.
                예)"a"+"b" == String.concat("a","b")</li>
        <li>문자열과 수를 + 연산 했을 때 수를 문자열로 취급한다.</li>
        <li> + 연산을 제외한 모든 연산은 수로 변환한다.</li>
        <li>문자열의 자동형변환 시 문자열이 수가 될 수 없으면 NaN가 반환된다. (Java는 NumberFormatException 오류발생)</li>
        <li></li>
    </ul>

    <h2>비교 연산자</h2>
    <p>(이항 : --, !=, >=, <=, ===), (단항: !), (js는 자료형의 equals가 없다)</p>
    <ul>
        <li>1==1 비교 :
            <script>document.write(1==1)</script>
        </li>
        <li>1=='1' 형변환 하여 비교 :
            <script>document.write(1=="1")</script>
        </li>
        <li>1==='1' :
            <script>document.write(1==="1")</script></br>
            === :: 형변환 없이 두개가 완전히 같은지 비교 (=완전동등비교)
        </li>

        <li>"13">=1 :
            <script>document.write("13">=1)</script>
        </li>
        <li>"십삼">=1 :
            <script>document.write("십삼">=1)</script></br>
            (NaN>=1)
        </li>
        <li>"십삼" == "십삼" :
            <script>document.write("십삼"=="십삼")</script></br>
            <!--자바스크립트는 데이터 형태가 같기때문에 같다고 한다. 자바는 String이 리터럴하게 선언하면 같은 값을 참조한다. 따라서 이 경우는 같다. -->
        </li>
        <li>"십삼" === "십삼" :
            <script>document.write("십삼"==="십삼")</script></br>
        </li>
        <li>"십삼" == new String("십삼") :
            <script>document.write("십삼"==new String("십삼"))</script></br>
            ( new String("십삼") -> "십삼" 으로 형변환 하여 기본값만 참조 후 비교 연산)
        </li>
        <li>"십삼" === new String("십삼") :
            <script>document.write("십삼"===new String("십삼"))</script></br>
            ( 기본형 != 자료형 이기 때문에 같지 않다. )
            ( java의 String은 리터럴 하게 선언하면 같은 값을 참조하기 때문)
            <!--자바는 이 경우 좌 우의 주소가 다름 (새로운 객체 생성) 따라서 false의 결과가 나온다. 결과는 같지만 이유가 다르니 이부분 체크! -->
        </li>
    </ul>

    <h2>기본형과 랩퍼클래스와 자동완성!</h2>
    <ul>
        <li>랩퍼클래스 Number, BigInt, String Boolean 기본테이터 타입을 도와주는 필드의 집합</li>
        <li>기본형에서 바로 랩퍼 클래스의 필드를 접근하는 것처럼 사용 가능하다. (자동완성)</li>
        <li>문자열도 char[]의 형태로 메모리에 저장되어 있기 때문에 랩퍼 클래스 String 에서 필드를 호출한다.</li>
        <li></li>
    </ul>

<!-- 🎀  여기 채워오는게 숙제//모던자바스크립트 참고 5-1,2,3,4,5,5 보고/ 2-4,5,7,8,9 4-1,4-4,4-5는 오늘했다요
        11-1~8시간되면 봐요(예습)-->
    <h2>Number 랩퍼 클래스의 유용한 함수들</h2>
    <ul>
        <li>isNaN("십") : 매개변수가 수로 '형변환'이 불가능한지 확인 (불가능시 true, 가능 false) </li>
        <li>Number.isNaN(NaN,"십"*3) : 매개변수를 수로 형변환 하지 않고 매개변수가 NaN인지만 체크 (NaN:true)</li>
        <!--
             isNaN("십") 이면 이때 십이 형변환이 불가능하므로 true
             umber.isNaN(NaN,"십"*3) 이때 "십"이 형변환되며 NaN이 되고 NaN*3=NaN 이므로 NaN값이 된다, 따라서 false
        -->
        <li>Number.EPSILON : 1과 1보다 큰 숫자 중에서 가장 작은 숫자와의 차이와 같다.(약 2.22044604925031308084772633361816 * 10 ^-16)
            부동소수점으로 인해 발생하는 오차를 해결하기 위해 사용.</li>
        <li>Number.MAX(MIN)_VALUE : 가장 큰(작은)양수값.</li>
        <li>Number.MAX(MIN)_SAFE_INTEGER : 자바스크립트에서 안전하게 표현할수 있는 가장 큰(작은) 정수값</li>
        <li>Number.POSITIVE(NEGATIVE)_INFINITY 양(음)의 무한대</li>
        <li>Number.NaN: 숫자가 아님.</li>
        <li>Number.isFinite(수) : 인수로 전달된 숫자값이 유한수 인지 검사하여 불리언으로 반환,암묵적 타입변환X</li>
        <li>Number.isInteger(수) : 인수로 전달된 숫가값이 정수인지 검사하여 불리언으로 반환, 암묵적 타입변환X</li>
        <li>Number.isSafeInteger(수) : 인수로 전달됫 숫자값이 안전한 정수인지 검사하여 불리언으로 반환 (+- 2^53-1 사이 정수값), 암묵적 타입변환 X</li>
        <li>Number.prototype.toExponential 숫자를 지수표기법으로 변환하여 문자열로 반환.
            ex) (77.1234).toExponential(2); // 7.71e+1
            ex) 77.toExponential();// SyntaxError(.뒤의 의미가 모호하다 따라서 괄호를 치거나 공백을 두어 표기하면 에러를 없앨 수 있다.
                ->>(77).to~ 또는 77 .to~</li>
        <li>Number.prototype.toFixed : 숫자를 반올림하여 문자열로 반환. 반올림하는 소수점 이하 자릿수를 나타내는 0~20사이의 정수값을 인수로 전달 할 수 있다.</li>
        <li>Number.prototype.toPrecision: 인수로 전달받은 전체자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열로 반환</li>
        <li>Number.prototype.toString : 숫자를 문자열로 변환하여 반환한다. 인수를 생략하면 기본 십진법 반환
            ex) 10.toString();//10
                16.toString(2);//10000(2진법)
                16.toString(8);//20 (8진법)</li>

    </ul>
    <h2>Math 의 유용한 함수들</h2>
    <ul>
        <li>Math.PI : 원주율 값 반환</li>
        <li>Math.abs : 인수로 전달된 숫자의 절대값을 반환 ( '',[],null ->0으로 반환 그외는 NaN)</li>
        <li>Math.round : 인수로 전달된 숫자의 소수점 이하를 반올림한 정수를 반환
            ex) Math.round(1.4) ;//1
                Math.round();//NaN</li>
        <li>Math.ceil/floor : 인수로 전달된 숫자의 소수점 이하를 올림(/내림)한 정수를 반환</li>
        <li>Math.sqrt : 인수로 전달된 숫자의 제곱근을 반환</li>
        <li>Math.random : 임의의 난수를 반환한다. 0이상 1미만의 실수 </li>
        <li>Math.pow(num1,num2) : num1을 밑으로 num2를 지수로 거듭제곱한 결과
            ES7에 도입한 ** 지수연산자를 사용하면 가독성이 더 좋다.</li>
        <li>Math.max : 전달받은 인수중에서 가장 큰 수를 반환 (전달되지 않으면 -Infinity를 반환)</li>
        <li>Math.min : 전달받은 인수중에서 가장 작은 수를 반환 (전달되지 않은면 Infinity를 반환)</li>
    </ul>
    <h2>String 랩퍼클래스의 유용한 함수들</h2>
    <ul>
        <li>String.prototype.indexOf : 대상 문자열에서 인수로 전달받은 문자열을 검색하여 첫번째 인덱스를 반환.
            (검색실패시 -1 반환) ex)문자열.indexof('검색문자',3): 인덱스 3으로 부터 '검색문자'를 검색하여 인덱스 반환
            대상문자열에 특정 문자열이 존재하는지 확인할때 유용, ES6에서 String.prototype.includes 메서드를 사용하면 가독성이 더 좋다.</li>
        <li>String.prototype.search :  대상문자열에서 인수로 전달받은 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스를 반환.(실패시 -1반환)</li>
        <li>String.prototype.includes :  대상 문자열에 인수로 전달받은 문자열이 포함되어있는지 확인 그 결과를 불리언 값으로 반환.</li>
        <li>String.prototype.startsWith : 대상 문자열이 인수로 전달받은 문자열로 시작하는지 확인하여 그 결과를 불리언 값으로 반환.</li>
        <li>String.prototype.endsWith :  대상 문자열이 인수로 전달받은 문자열로 끝나는지 확인하여 그 결과를 불리언 값으로 반환</li>
        <li>String.prototype.charAt : 대상 문자열에서 인수로 전달받은 인덱스에 위치한 문자를 검색하여 반환(0부터시작~)</li>
        <li>✨String.prototype.substring :  대상문자열에서 첫번째 인수로 전달받은 인덱스에 위치하는 문자부터 두번째 인수로 전달받은 인덱스에 위치하는 문자의 바로 이전문자 까지의 부분 문자열을 반환한다.
                                        - 첫번째 인수 > 두번째 인수 인 경우 두 인수는 교환된다.
                                        - 인수<0 또는 NaN인 경우 0으로 취급된다.
                                        - 인수 > 문자열의 길이 인 경우 문자열의 길이로 취급된다.</li>
        <li>✨String.prototype.slice :  substring과 동일하게 동작하나 여기선 음수의 인수를 전달할 수 있다.
                                     음수의 인수 전달시, 대상 문자열의 가장 뒤에서 부터 시작하여 문자열을 잘라내 반환한다.</li>
        <li>String.prototype.toUpperCase : 대상 문자열을 모두 대문자로 변경한 문자열을 반환</li>
        <li>String.prototype.toLowerCase : 대상 문자열을 모두 소문자로 변경한 문자열을 반환</li>
        <li>String.prototype.trim :  대상 문자열 앞 뒤에 공백문자가 있을 경우 이를 제거한 문자열 반환</li>
        <li>String.prototype.repeat :  대상 문자열을 인수로 전달받은 정수만큼 반복해 연결한 새로운 문자열을 반환 (인수가 0이면 빈 문자열 반환, 인수가 음수이면 RangError을 발생</li>
        <li>✨String.prototype.replace :  대상 문자열에서 첫번쨰 인수로 전달받은 문자열 또는 정규표현식을 검색하여 두번째 인수로 전달한 문자열로 치환한 문자열을 반환.</li>
        <li>String.prototype.split : 대상 문자열에서 첫번째 인수로 전달한 문자열 또는 정규표현식을 검색하여 문자열을 구분한 후, 분리된 각 문자열로 이루어진 배열을 반환한다.
                                    인수로 빈 문자열 전달시, 각문자를 모두 분리하고 인수를 생략하면 대상 문자열 전체를 단일요소로 하는 배열을 반환한다.</li>
    </ul>
    <script>
    let num;
    console.log(num+ " : "+(typeof num));
    console.log((num+10) + " : "+(typeof num));

    num = 13.33;
    console.log(num+ " : "+(typeof num)); // type of 는 data의 타입을 문자열로 반환
    num = 13;
    console.log(num+ " : "+(typeof num));
    num = Number("십삼"); // java 의 Integer.parseInt 와 같다 (문자열을 수로 형변환)
    console.log(num+ " : "+(typeof num)); // NaN: 수와 관련된 오류를 표시
    console.log((13-"일")+" : "+(typeof num)); //NaN (Not a Number)
    console.log((1/0)+" : " +(typeof num)); //Infinity

    let bigInt = 123123123123123123123123123123123123123123123132123123123;
    console.log (bigInt + " : " + (typeof bigInt)); // number 부동 소수점으로 표현
    bigInt = 123123123123123123123123123123123123123123123132123123123n // 큰정수 bigInt
    console.log (bigInt + " : " + (typeof bigInt));

    let string ="안녕";
    console.log(string +" : "+ (typeof string)); // char [] ={'안','녕'};
    string = new String("안녕");
    console.log(string +" : "+ (typeof string)); // String s = "안녕"; or new String("안녕");
    // 배열을 자료형으로 보기가 어렵다.
    string = '안녕~' ; // js는 "",'' 똑같이 문자열
    console.log(string +" : "+ (typeof string));
    let name ='현주';
    string = `안녕하세요~  ${name} 씨~ ` //``백틱으로 선언하는 문자열은 표현식으로 +연산을 대신할 수 있다.
    console.log(string +" : "+ (typeof string));


    //기본형의 랩퍼 클래스와 자동완성!
    // 기본형에 필드가 없지만 마치 자료형인것 처럼 사용가능하다.
    let i =1000.1234564;
    console.log("i.toFixed(4) : "+i.toFixed(4)) // 기본형에는 필드가 존재하지 않지만 있는 것 처럼 쓸 수 있다.
                                                // 이 때 필드는 Number것 =>>.toFixed : 4자리 까지 출력하고 반올림
    console.log(new Number(i).toFixed(4))// 본래모습.

    // js의 자동형변환에 자동완성이 이해를 더욱 어렵게 할 수 있다,

    console.log(`0.1+0.2=${0.1+0.2}`) //정밀도 손실 (모든언어 다 손실이 있음)

    //NaN
    let input ="십";
    console.log(`NaN==NaN : ${NaN==NaN}`);
    console.log(`Number.parseInt("십")==NaN : ${Number.parseInt(input)==NaN}`)
    console.log(`isNaN("십") : ${isNaN(input)}`); // "십"이 숫자로 형변환 불가능한가?
    console.log(`Number.isNaN("십") : ${Number.isNaN(input)}`); // data가 NaN인지만 확인 (지금 input은 string값이다) 따라서 false
    console.log(`Number.parseInt("십") : ${Number.isNaN(parseInt(input))}`); //true

    console.log("isNaN(공백) : " +isNaN(" ")); // 공백을 0으로 취급 즉, 형변환 가능 false.
    console.log("isNaN(true) : " + isNaN(true)); // true는 1로 변환 즉, 형변환 가능 false.

    //+연산
    //자바스크립트는 문자열과 수를 연산할때 꼭 수로 형변환 한다. (더하기 연산 제외)
    console.log("1"+1); // -> '11' //더하기연산은 문자열을 수로 형변환 하지 않고 수를 문자열로 만들고 연산한다. (자바와 같음)
    console.log("1"-1); // 1-1 =0 //더하기가 아닌 연산은 계산된다. (즉, 문자열이 수로 형변환 되어져 계산된다)
    console.log("일"-1); //NaN-1 =>NaN (수만 가능한 연산을 할 때 js는 문자열을 수로 형변환 하는데 이때 NaN이 발생한다.)


</script>


</body>
</html>