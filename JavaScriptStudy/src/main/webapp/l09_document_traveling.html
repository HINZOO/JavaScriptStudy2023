<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>document 란?</title>
</head>
<body>
    <h1>📂 document와 window</h1>
    <p>자바스크립트를 브라우저에서 실행하면 브라우저와 관련된 정보를 window에 저장하고 전역 설정한다.
        브라우저에서 출력하는 html 문서를 객체로 만들어서 document에 저장한다.
    </p>
    <ul>
        <li>window : BOM Browser Object Model 브라우저정보와 전역</li>
        <li>window.document :  DOM Document Object Model html 문서를 객체로 제공</li>
        <li>DOM Tree : 문서에 존재하는 태그들을 중첩(자식)관계로 그래프를 그린 것.</li>
        <li>DOM Tree root : 모든 태그의 조상 html 또는 body 태그</li>
        <li>DOM Tree 자식 : 해당 태그의 바로 하위 중첩 태그 CSS] node>childNode</li>
        <li>DOM Tree 자손 : 해당 태그의 모든 하위 태그 CSS] node childNode</li>
        <li>DOM Tree 형제 : 해당 태그와 인접한 태그들 CSS] node ~ sibling</li>
        <li>DOM Tree 부모 : 해당 태그를 중첩하는 태그</li>
        <li>DOM Tree 조상 : 해당 태그를 중첩하는 태그의 부모 or 부모의 부모 or 부모의 부모의 부모...</li>
        <li>✨ CSS 선택자 꼭 암기 ✨</li>
    </ul>

    <h2>📂 node 객체에 필드로 존재하는 부모 자식 관계1(암기X : 자주사용하지않음)</h2>
    <p> textNode + elementNode 를 찾는 필드</p>
    <ul id="domTraveling1">
            <li>node.parentNode : 부모노드</li>
            <li>node.childNodes : 자식노드들 []</li> <!--HTML Collection-->
            <li>node.firstChild : 첫번째 자식</li>
            <li>node.lastChild : 마지막 자식</li>
            <li>node.previousSibling : 인접한 이전 형제</li>
            <li>node.nextSibling : 인접한 다음 형제</li>
    </ul>
    <script><!--'\n'의 textNode 가 존재함-->
    // script 도 node 로 취급당하고 객체생성대신 실행을 한다.
    // >> ul 객체가 생성 된 후 script 가 실행된다.
        const domTraveling1= document.getElementById("domTraveling1")
        console.log("자신node", domTraveling1);
        console.log("부모node", domTraveling1.parentNode);
        console.log("자식node", domTraveling1.childNodes);
        console.log("첫번째 자식node", domTraveling1.firstChild);
        console.log("마지막 자식node", domTraveling1.lastChild);
        console.log("이전형제 node", domTraveling1.previousSibling);
        console.log("다음형제 node", domTraveling1.nextSibling);
    </script>

    <h2>📂 node 객체에 필드로 존재하는 부모 자식 관계2(암기✨표시한것만)</h2>
    <p> elementNode 를 찾는 필드</p>
    <ul id="test">
        <li>✨node.parentElement : 부모노드</li>
        <li>✨node.children : 자식노드들 []</li>
        <li>node.firstElementChild : 첫번째 자식</li>
        <li>node.lastElementChild : 마지막 자식</li>
        <li>node.previousElementSibling : 인접한 이전 형제</li>
        <li>✨node.nextElementSibling : 인접한 다음 형제</li>
    </ul>
    <script> //script 태그를 요소노드 (ElementNode) 로 취급한다.
        const test = document.getElementById("test");// 똑같은 id 가 선언된 여러 요소중 처음 발견된 node 한개만 반환
        console.log("자신요소 node",test);
        console.log("부모요소 node",test.parentElement); //부모는 절대 textNode 일수 없기때문에 =parentNode 와 결과값이 같다.
        console.log("자식요소 node",test.children);//텍스트노드를 제외한다.
        console.log("첫번째 자식요소 node",test.firstElementChild);
        console.log("마지막 자식요소 node",test.lastElementChild);
        console.log("인접한 이전 형제요소 node",test.previousElementSibling);
        console.log("인접한 다음 형제요소 node",test.nextElementSibling);
    </script>

    <h2>📂 document를 탐색하는 함수들(✨ 암기)</h2>
    <p>-배열로 찾아지는 node는 무조건 반복문으로 제어해야한다.</p>
    <p>- [node,node..].style.color="red"; (❌)</p>
    <p>-node.style.color="red"; (⭕)</p>
    <p>- JQuery 에선 가능하던데? <br>
        $(".blue").style("color","red"); // [li,li,li].style.color="red"<br>
        <!--$(".blue") == querySelectorAll(".blue")-->
         >> 이때 style 이 Iteration function 즉 반복문 함수이다.(cf.event함수도 IterationFunction)</p>
    <p>window js :  자바스크립트가 브라우저에서 실행될 때 ( window, document 객체를 반환)</p>
    <p>node js : 자바스크립트가 서버에서 자바처럼 실행되는 언어 (http : 서버객체)</p>
    <p>spring : 자바의 톰캣 서버를 제어하는 프레임워크 웹앱</p>
    <p>expressjs, nextjs, reactjs : 자바스크립트이  nodejs 서버를 제어하는 프레임워크 웹앱</p>
    <ul id ="test2">
        <li class = "blue">✨document(node).getElementById("id")  : id로 노드를 검색 (return node)</li> <!--여러개 중에 처음 찾은 1개만 참조-->
        <li class ="red">✨document(node).getElementsByTagName("tag") : 요소 이름으로 노드들을 검색(return HTMLCollection)</li>
        <li>✨document(node).getElementsByClassName("class") : 클래스 이름으로 노드들을 검색(return HTMLCollection)</li>
        <li class ="red">document.getElementsByName("name") : name 으로 노드들을 검색(return HTMLCollection)</li>
        <!--ES6 문법-->
        <li>✨document(node).querySelector(css) : css 선택자로 노드를 검색 (return node)</li>  <!--복수 선택자를 써도 하나만 출력-->
        <li>✨document(node).querySelectorAll(css) : css 선택자로 노드들을 검색 (return NodeList)</li>
        <!--하단부터는 암기X 심화-->
        <li>node.closest(css) : 해당 노드의 조상중에 해당 선택자와 동일한 노드가 있으면 반환</li>
        <li class ="red">document(node).matches(css) : 해당 선택자의 노드가 있는지 검색(return boolean)</li>
        <li class = "blue">node.contains(css) : 해당 선택자의 노드가 조상인지 확인 (return boolean)</li>
    </ul>

    <script>
        //#test2 요소에 text-shadow 를 적용해보세요 (querySelector(△),getElementById)
        //  querySelector 는 querySelectorAll 처럼 복수의 node를 검색후 , 맨 위의 것을 반환
        //  getElementById 는 id 선택자를 1개 찾는다. (복수를 우선으로 찾는 querySelector 보다 성능이 좋다)
        //#test2 > .red color:red
        //#test2 > .blue color:blue

        const test2 = document.getElementById('test2');
        test2.style.textShadow= "1px 1px 2px rgba(0,0,0,.5)";
        const redLi = test2.getElementsByClassName('red');//HTMLCollection 으로 반환 => for of 로 반복문 진행
     // const redLi2 = document.querySelectorAll("#test2 li.blue");//nodeList로 반환
            // 👓 코드를 보수하다보면 중첩요소가 더 많은 중첩을 하게 될 가능성이 높다.
            //    때문에 자식선택자보다는 자손선택자를 많이씀 (유지보수는 쉬워지나 성능하락)
            // 유지보수를 생각하면 선택자가 추상적이고, 성능을 생각하면 선택자를 구체화(ul#test2>li.blue) 한다.

        for (let r of redLi) {
            r.style.color='rgb(220,70,70)';
        }
        Array.from(redLi).forEach((li)=>{// 배열에서 Array 필드를 사용하고 싶을때 배열을  Array로 파싱하는 함수 =>Array.from(arr)
            li.style.textDecoration="underline";
        })

/*
        //😎 HTMLCollection은 forEach가 없다 for Each로 풀고싶으면 (개발자 선호)
        //   Array.from을 쓰고싶지 않다면 처음부터 querySelectorAll로 받자.NodeList반환되며 forEach가 있다.
        //   하지만 여기엔 map이나 reduce가 없기 때문에 멀티로 사용하고 싶다면 또 Array.from을 해줘야한다.
            const redli = Array.from(red);
            redli.forEach((li)=>{
                li.style.color="red";
            });
*/

        const blueLi = test2.getElementsByClassName('blue');
        for (let b of blueLi) {
            b.style.color= 'rgb(70,70,220)';
        }

        //for(시작;조건;증감) : 잘 안씀
        // for(let A in ARR) :  배열에서는 사용 안함
/*
        // 만약 in을 쓴다면 🔎 Object에서만 사용,
             //🍒 key 는 필드를 문자열이나 수로 참조하는것
             //     index key : 0, 1, 2, 3, 4 ,..
             //     Object key :  person.name (이때 name 은 필드)
             //                :  person["name"] (이때 "name"은  key)
            const blueLis = document.getElementsByClassName("blue");
            for(let i in blueLis){let li = blueLis[i]; li.style.color='blue'}
*/

        // const test2Li = test2.getElementsByTagName("li");// 노드(test2)에서 domtraveling할 수 있다.
        // console.log(test2Li);

    </script>

    <h2>📂 미리 지정되는 node 변수들</h2>
    <ul id ="test3">
        <li>id를 정의하면 id와 동일한 이름의 변수가 해당 노드를 참조.(실무에서는 사용하지 않는다. getElementById 권장)
            <ul>
                <li>👀 왜 안써?</li>
                <li>id는 document 유일한 선택자지만 여러개 선언해도 오류가 발생하지 않는다.(여러개 선언가능)</li>
                <li>만약 id가 여러개일 때 미리 생성된 id 변수를 쓰면 배열이 참조된다.(쓰지않는이유)</li>
                <li>만약 없는 id를 id 변수로 참조하면 '선언되지않았다'는 오류가 발생! getElementById는 null이 발생 </li>
            </ul>
        </li>
        <li>form 에 name을 정의하면 name과 동일한변수가 해당 form 노드를 참조(document.forms[name] 권장)</li>
        <li>form 에 중첩된 input 요소에 name 을 작성하면 노드의 자식으로 참조가능(**)</li>
        <li>form 에 중첩된 여러 input요소에 같은 name을 작성하면 RadioNodeList를 반환
            (만약 type이 radio 면 checked 된 value가 반환)</li>
        <li>document.body : 무조건 1개만 존재하는 모든 요소의 부모</li>
    </ul>
    <h2>📂 table node에서 행과 셀을 검색</h2>
    <ul>
        <li>tableNode.rows[수] : 해당 테이블의 몇번째 tr</li>
        <li>tableNode.rows[수].cells[tn] : 해당 테이블의 몇번째 tr의 몇번째 td</li>
    </ul>
    <table id="userTable">
        <tr> <!--0-->
            <td>한영범</td>
            <td>25</td>
            <td>조성윤</td>
        </tr>
        <tr><!--1-->
            <td>이창섭</td>
            <td>40</td>
            <td>권동호</td>
        </tr>
        <tr><!--2-->
            <td>류순호</td>
            <td>18</td>
            <td>김리현</td>
        </tr>
    </table>
    <script>
        console.log(userTable);
        userTable.rows[2].style.background="yellow";
        userTable.rows[1].cells[0].style.border = "1px solid purple";
    </script>
    

    <form name="loginForm" id="loginFormId" action="">
        <div>
            id : <input name="id" value = " acornCkm">
        </div>
        <div> <!--중첩된 여러 input요소에 같은 name을 작성하면 RadioNodeList를 반환-->
            id : <input name="id" value = " acornCkm">
        </div>
        <div>
            로그인 유지:
            <input type="radio" name="state"  value="1" checked>
            로그인 유지X:
            <input type="radio" name="state"  value="2" >
        </div>
    </form>
<script>
    console.log(test3);
    console.log(loginForm);
    console.log(loginFormId);
    console.log(loginForm.id); // 폼의 필드처럼 찾을 수 있다.
    console.log(loginFormId.id); // 폼의 필드처럼 찾을 수 있다.
    console.log(loginForm.state);
</script>


<!--Internal Style : 보통 header에 작성하지만 수업이니까 여기에서 작성-->
<style>
    /* boxContainer 안에 .box들을 inline-block에 배경색이 lightgray로 만드세요.*/
    #boxContainer>.box{
        /*height: auto; 블럭 내부의 컨텐츠의 높이 만큼 블럭의 높이를 지정*/
        width: 200px;
        height: 200px;
        display:inline-block;
        background-color: lightgray;
        text-align:center;
        line-height: 200px;
    }

</style>

<h2>선택자 연습 문제</h2>
    <div id="boxContainer">
        <p class="box">
            <span>저는</span>
            <strong>박스 1</strong>
            <span>입니다!</span>
        </p>
        <p class="box">
            <span>저는</span>
            <strong>박스 2</strong>
            <span>입니다!</span>
        </p>
        <p class="box">
            <span>저는</span>
            <strong>박스 3</strong>
            <span>입니다!</span>
        </p>
        <p class="box">
            <span>저는</span>
            <strong>박스 4</strong>
            <span>입니다!</span>
        </p>
        <p class="box">
            <span>저는</span>
            <strong>박스 5</strong>
            <span>입니다!</span>
        </p>
    </div>
    <script>

        // .box에 마우스를 올리면 border="1px solid red"으로 하세요
        // .box에 마우스가 떠나면 border="none"으로 하세요
        // .box를 누르면 (onclick)좌우의 형제의 display를 none으로 만드세요
      const boxs = boxContainer.children;
      console.log(boxs);

      const box3 = document.getElementById('boxContainer');
      console.log(box3.children);

      const boxs2 = document.getElementsByClassName("box");
      console.log(boxs2);


      const boxLi = document.querySelectorAll('#boxContainer>.box');
      // const boxLi2 = boxContainer.querySelectorAll('.box');
      console.log(boxLi);
      Array.from(boxLi).forEach((box)=>{
          box.onmouseover=(e)=>{
              e.target.style.border="1px solid red";
          }
          box.onmouseleave=(e)=>{
              e.target.style.border="none"
          }
          box.onclick=(e)=>{
              e.target.previousElementSibling.style.display="none";
              e.target.nextElementSibling.style.display="none";
          }
      })

/*
      for(let b of boxLi) {

          b.onmouseenter = function (e) {
              this.style.border = "1px solid red";
          }
          b.onmouseleave = function (e) {
              this.style.border = "none";
          }
          b.onclick=function (e){
              this.previousElementSibling.style.display ="none";
              this.nextElementSibling.style.display ="none";
          }
      }
*/


    </script>

    <h2>선택자 문제2</h2>
    <table id="ex2Table" style="width: 100%">
        <tr>
            <td>1</td>
            <td>경민</td>
            <td>38</td>
            <td>강사</td>
        </tr>
        <tr>
            <td>2</td>
            <td>윤식</td>
            <td>24</td>
            <td>학생</td>
        </tr>
        <tr>
            <td>3</td>
            <td>은주</td>
            <td>25</td>
            <td>학생</td>
        </tr>
        <tr>
            <td>4</td>
            <td>동홍</td>
            <td>26</td>
            <td>학생</td>
        </tr>
        <tr>
            <td>5</td>
            <td>동일</td>
            <td>35</td>
            <td>학생</td>
        </tr>
    </table>
    <script>
        //ex2Table의 모든 td 를 선택하세요
        //모든 td에 마우스를 올리면(onmouseover) border를 1px solid 로 지정하세요
        //이때 td가 속한 tr의 배경색을 lightgray로 바꾸세요
        //마우스가 td 에서 빠져 나가면 td에 정의된 board와 background를 제거하세요

        const tList=document.getElementById('ex2Table');

        console.log(tList.getElementsByTagName("td"));
        const tdList = tList.getElementsByTagName("td");
        const trList = tList.getElementsByTagName("tr")
        // Array.from(trList).forEach((r)=>{
        //     r.onmouseover=(e)=>{
        //        e.target.style.background="lightgray";
        //     };
        // })
        Array.from(tdList).forEach((d)=>{
           d.onmouseover=(e)=>{
               e.target.style.border="1px solid";
               e.target.parentElement.style.background="lightgray";
           };
           d.onmouseleave=(e)=>{
               e.target.style.border="none";
               e.target.parentElement.style.background="none";
           }
        });

   </script>

</body>
</html>